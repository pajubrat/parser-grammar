

\========================================================================
# 1
['Pekka', 'nukkui']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'nukku-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "nukku"

		[[D Pekka] T/fin] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*nukku]
			=[[D Pekka] T/fin{V}]

6.
	>>>	Trying candidate parse [[D Pekka] T/fin{V}] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] T/fin{V}].
				Extracted head "nukku" from T/fin and created [[D Pekka] [T/fin nukku]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:1 [T/fin [<DP>:1 nukku]]]
				= [<D Pekka> [T/fin [<D Pekka> nukku]]]
			Dropping A-/A-bar movement.
			= [<D Pekka> [T/fin [<D Pekka> nukku]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:1 [T/fin [<DP>:1 nukku]]] into LF...
				Transfer to LF successful.


\========================================================================
# 2
['Pekka', 'ihailee', 'Merjaa']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', '$v', 'ihaile-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "v"

		[[D Pekka] T/fin] + v
			Filtering out impossible merge sites...
			Sink "v" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*v]
			=[[D Pekka] T/fin{v}]

6.

		Consume "ihailee"

		[[D Pekka] T/fin{v}] + ihailee
			Filtering out impossible merge sites...
			Sink "ihailee" into T/fin{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin{v}*ihailee]
			=[[D Pekka] T/fin{v,V}]

7.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{v,V}]

8.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] T/fin{v,V}] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [v ihailee]]]] D] due to bad left branch.
		Exploring solution number (1) =[T/fin{v,V} D]
			T/fin{v,V} cannot be opened.
			=[[D Pekka] [T/fin{v,V} D]]

9.

		Consume "Merjaa"

		[[D Pekka] [T/fin{v,V} D]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [T/fin{v,V} D{N}]]

10.
	>>>	Trying candidate parse [[D Pekka] [T/fin{v,V} D{N}]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{v,V} D{N}]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [v{V} D{N}]]]
				Extracted head "ihailee" and reconstructed it = [[D Pekka] [T/fin [v [ihailee D{N}]]]]
				Extracted head "Merjaa" from D and created [[D Pekka] [T/fin [v [ihailee [D Merjaa]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:2 [T/fin [<DP>:2 [v [ihailee [D Merjaa]]]]]]
				= [<D Pekka> [T/fin [<D Pekka> [v [ihailee [D Merjaa]]]]]]
			Dropping A-/A-bar movement.
			= [<D Pekka> [T/fin [<D Pekka> [v [ihailee [D Merjaa]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:2 [T/fin [<DP>:2 [v [ihailee [D Merjaa]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 3
['Pekka', 'antoi', 'kirjan', 'Merjalle']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', '$v', 'anta-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "v"

		[[D Pekka] T/fin] + v
			Filtering out impossible merge sites...
			Sink "v" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*v]
			=[[D Pekka] T/fin{v}]

6.

		Consume "antaa"

		[[D Pekka] T/fin{v}] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into T/fin{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin{v}*antaa]
			=[[D Pekka] T/fin{v,V}]

7.
		Next word contains multiple morphemes ['$asp', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:v,!COMP:*'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{v,V}]

8.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:v,!COMP:*', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:v,!COMP:*']

		Consume "D"

		[[D Pekka] T/fin{v,V}] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [v antaa]]]] D] due to bad left branch.
		Exploring solution number (1) =[T/fin{v,V} D]
			T/fin{v,V} cannot be opened.
			=[[D Pekka] [T/fin{v,V} D]]

9.

		Consume "kirja"

		[[D Pekka] [T/fin{v,V} D]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [T/fin{v,V} D{N}]]

10.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [T/fin{v,V} D{N}]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, P(lle).
				Avoid T/finP as SPEC, P(lle).
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T/fin [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [T/fin{v,V} D{N}]] + P(lle) = -98]
				[T/fin{v,V} D{N}] + P(lle) = -194]
				D{N} + P(lle) = 9]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D Pekka] [T/fin{v,V} D{N}]]; P(lle)]
			3. [[T/fin{v,V} D{N}]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [T/fin{v,V} [[D kirja] P(lle)]]]

11.

		Consume "D"

		[[D Pekka] [T/fin{v,V} [[D kirja] P(lle)]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D}]]]

12.

		Consume "Merja-"

		[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D}]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]]

13.
	>>>	Trying candidate parse [[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [v{V} [[D kirja] P(lle){D,N}]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [T/fin [v [antaa [[D kirja] P(lle){D,N}]]]]]
				Extracted head "D{N}" from P(lle) and created [[D Pekka] [T/fin [v [antaa [[D kirja] [P(lle) D{N}]]]]]]
			Reconstructing head movement for D{N}.
				Extracted head "Merja-" from D and created [[D Pekka] [T/fin [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:4 [T/fin [<DP>:4 [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]
				= [<D Pekka> [T/fin [<D Pekka> [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:4 [T/fin [<DP>:4 [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [T/fin [<D Pekka> [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:4 [T/fin [<DP>:4 [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 4
['Pekka', 'ei', 'nukkunut']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'nukku-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "nukku"

		[[D Pekka] [ei T]] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*nukku]
			=[[D Pekka] [ei T{V}]]

7.
	>>>	Trying candidate parse [[D Pekka] [ei T{V}]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei T{V}]].
				Extracted head "nukku" from T and created [[D Pekka] [ei [T nukku]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:1 [ei [<DP>:1 [T nukku]]]]
				= [<D Pekka> [ei [<D Pekka> [T nukku]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:1 from memory buffer into Spec of nukku
				Result [<D Pekka>:1 [ei [<DP>:1 [T [<DP>:1 nukku]]]]]
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> nukku]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:1 [ei [<DP>:1 [T [<DP>:1 nukku]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 5
['Pekka', 'ei', 'ihaile', 'Merjaa']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', '$v', 'ihaile-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "v"

		[[D Pekka] [ei T]] + v
			Filtering out impossible merge sites...
			Sink "v" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*v]
			=[[D Pekka] [ei T{v}]]

7.

		Consume "ihailee"

		[[D Pekka] [ei T{v}]] + ihailee
			Filtering out impossible merge sites...
			Sink "ihailee" into T{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T{v}*ihailee]
			=[[D Pekka] [ei T{v,V}]]

8.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{v,V}]]

9.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei T{v,V}]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v ihailee]]]]]] D] due to bad left branch.
				Reject [[ei [T [v ihailee]]] D] due to bad left branch.
		Exploring solution number (1) =[T{v,V} D]
			T{v,V} cannot be opened.
			=[[D Pekka] [ei [T{v,V} D]]]

10.

		Consume "Merjaa"

		[[D Pekka] [ei [T{v,V} D]]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [ei [T{v,V} D{N}]]]

11.
	>>>	Trying candidate parse [[D Pekka] [ei [T{v,V} D{N}]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{v,V} D{N}]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [v{V} D{N}]]]]
				Extracted head "ihailee" and reconstructed it = [[D Pekka] [ei [T [v [ihailee D{N}]]]]]
				Extracted head "Merjaa" from D and created [[D Pekka] [ei [T [v [ihailee [D Merjaa]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:3 [ei [<DP>:3 [T [v [ihailee [D Merjaa]]]]]]]
				= [<D Pekka> [ei [<D Pekka> [T [v [ihailee [D Merjaa]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:3 from memory buffer into Spec of v
				Result [<D Pekka>:3 [ei [<DP>:3 [T [<DP>:3 [v [ihailee [D Merjaa]]]]]]]]
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v [ihailee [D Merjaa]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:3 [ei [<DP>:3 [T [<DP>:3 [v [ihailee [D Merjaa]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 6
['Pekka', 'ei', 'antanut', 'kirjaa', 'Merjalle']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', '$v', 'anta-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "v"

		[[D Pekka] [ei T]] + v
			Filtering out impossible merge sites...
			Sink "v" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*v]
			=[[D Pekka] [ei T{v}]]

7.

		Consume "antaa"

		[[D Pekka] [ei T{v}]] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into T{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T{v}*antaa]
			=[[D Pekka] [ei T{v,V}]]

8.
		Next word contains multiple morphemes ['$par', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{v,V}]]

9.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei T{v,V}]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v antaa]]]]]] D] due to bad left branch.
				Reject [[ei [T [v antaa]]] D] due to bad left branch.
		Exploring solution number (1) =[T{v,V} D]
			T{v,V} cannot be opened.
			=[[D Pekka] [ei [T{v,V} D]]]

10.

		Consume "kirja"

		[[D Pekka] [ei [T{v,V} D]]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [ei [T{v,V} D{N}]]]

11.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [ei [T{v,V} D{N}]]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, P(lle).
				Avoid Neg/finP as SPEC, P(lle).
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [ei [T [v [antaa [D kirja]]]]] as left branch because it constitutes illicit structure.
				Avoid [[T{v,V} D{N}], P(lle)] because the operation breaks up an existing selectional dependency.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [ei [T{v,V} D{N}]]] + P(lle) = -98]
				[ei [T{v,V} D{N}]] + P(lle) = -194]
				[T{v,V} D{N}] + P(lle) = -191]
				D{N} + P(lle) = 12]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D Pekka] [ei [T{v,V} D{N}]]]; P(lle)]
			3. [[T{v,V} D{N}]; P(lle)]
			4. [[ei [T{v,V} D{N}]]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [ei [T{v,V} [[D kirja] P(lle)]]]]

12.

		Consume "D"

		[[D Pekka] [ei [T{v,V} [[D kirja] P(lle)]]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D}]]]]

13.

		Consume "Merja-"

		[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D}]]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]]

14.
	>>>	Trying candidate parse [[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [v{V} [[D kirja] P(lle){D,N}]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [ei [T [v [antaa [[D kirja] P(lle){D,N}]]]]]]
				Extracted head "D{N}" from P(lle) and created [[D Pekka] [ei [T [v [antaa [[D kirja] [P(lle) D{N}]]]]]]]
			Reconstructing head movement for D{N}.
				Extracted head "Merja-" from D and created [[D Pekka] [ei [T [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:7 [ei [<DP>:7 [T [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]
				= [<D Pekka> [ei [<D Pekka> [T [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:7 from memory buffer into Spec of v
				Result [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 7
['Pekka', 'kaski', 'heidan', 'nukkua']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'kaske-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "käske"

		[[D Pekka] T/fin] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*käske]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{V}]

7.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] T/fin{V}] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [T/fin [<D Pekka> käske]]] as left branch because it constitutes illicit structure.
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				Avoid [T/fin{V} D] due to local agreement failure.
				Prioritize [T/fin{V} D] due to complement selection.
				[[D Pekka] T/fin{V}] + D = -197]
				T/fin{V} + D = -42]
		Ranking completed:
			1. [T/fin{V}; D]
			2. [[[D Pekka] T/fin{V}]; D]
		Exploring solution number (1) =[T/fin{V} D]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} D]]

8.

		Consume "heidän"

		[[D Pekka] [T/fin{V} D]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [T/fin{V} D{N}]]

9.
		Next word contains multiple morphemes ['$-ta', 'nukku-']

		Consume "Ainf"

		[[D Pekka] [T/fin{V} D{N}]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske <D heidän>]]]] Ainf] due to bad left branch.
				Reject [[T/fin [käske <D heidän>]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf]]]

10.

		Consume "nukku"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf]]] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*nukku]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]]

11.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] Ainf{V}]]]]
				Extracted head "nukku" from Ainf and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf nukku]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:4 [T/fin [<DP>:4 [käske [[D heidän] [Ainf nukku]]]]]]
				= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf nukku]]]]]]
			Dropping A-/A-bar movement.
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] nukku]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:4 [T/fin [<DP>:4 [käske [[D heidän]:5 [Ainf [(DP):5 nukku]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 8
['Pekka', 'kaski', 'heidan', 'ihailla', 'Merjaa']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'kaske-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "käske"

		[[D Pekka] T/fin] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*käske]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{V}]

7.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] T/fin{V}] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [T/fin [<D Pekka> käske]]] as left branch because it constitutes illicit structure.
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				Avoid [T/fin{V} D] due to local agreement failure.
				Prioritize [T/fin{V} D] due to complement selection.
				[[D Pekka] T/fin{V}] + D = -197]
				T/fin{V} + D = -42]
		Ranking completed:
			1. [T/fin{V}; D]
			2. [[[D Pekka] T/fin{V}]; D]
		Exploring solution number (1) =[T/fin{V} D]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} D]]

8.

		Consume "heidän"

		[[D Pekka] [T/fin{V} D]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [T/fin{V} D{N}]]

9.
		Next word contains multiple morphemes ['$-ta', '$v', 'ihaile-']

		Consume "Ainf"

		[[D Pekka] [T/fin{V} D{N}]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske <D heidän>]]]] Ainf] due to bad left branch.
				Reject [[T/fin [käske <D heidän>]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf]]]

10.

		Consume "v"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]]

11.

		Consume "ihailee"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]] + ihailee
			Filtering out impossible merge sites...
			Sink "ihailee" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*ihailee]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

12.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

13.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v ihailee]]]]]]]] D] due to bad left branch.
				Reject [[T/fin [käske [[D heidän] [Ainf [[D heidän] [v ihailee]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v ihailee]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]]

14.

		Consume "Merjaa"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]

15.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf{v,V} D{N}]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v{V} D{N}]]]]]]
				Extracted head "ihailee" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [ihailee D{N}]]]]]]]
				Extracted head "Merjaa" from D and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:8 [T/fin [<DP>:8 [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]]
				= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]]
			Dropping A-/A-bar movement.
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [ihailee [D Merjaa]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:8 [T/fin [<DP>:8 [käske [[D heidän]:9 [Ainf [(DP):9 [v [ihailee [D Merjaa]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 9
['Pekka', 'kaski', 'heidan', 'antaa', 'kirjan', 'Merjalle']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'kaske-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "käske"

		[[D Pekka] T/fin] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*käske]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{V}]

7.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] T/fin{V}] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [T/fin [<D Pekka> käske]]] as left branch because it constitutes illicit structure.
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				Avoid [T/fin{V} D] due to local agreement failure.
				Prioritize [T/fin{V} D] due to complement selection.
				[[D Pekka] T/fin{V}] + D = -197]
				T/fin{V} + D = -42]
		Ranking completed:
			1. [T/fin{V}; D]
			2. [[[D Pekka] T/fin{V}]; D]
		Exploring solution number (1) =[T/fin{V} D]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} D]]

8.

		Consume "heidän"

		[[D Pekka] [T/fin{V} D]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [T/fin{V} D{N}]]

9.
		Next word contains multiple morphemes ['$-ta', '$v', 'anta-']

		Consume "Ainf"

		[[D Pekka] [T/fin{V} D{N}]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske <D heidän>]]]] Ainf] due to bad left branch.
				Reject [[T/fin [käske <D heidän>]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf]]]

10.

		Consume "v"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]]

11.

		Consume "antaa"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*antaa]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

12.
		Next word contains multiple morphemes ['$asp', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:v,!COMP:*'] into working memory.

		Consume "$D"

			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

13.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:v,!COMP:*', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:v,!COMP:*']

		Consume "D"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]]]] D] due to bad left branch.
				Reject [[T/fin [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v antaa]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]]

14.

		Consume "kirja"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]

15.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, P(lle).
				Avoid T/finP as SPEC, P(lle).
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T/fin [käske [[D heidän] [Ainf [[D heidän] [v [antaa [D kirja]]]]]]]] as left branch because it constitutes illicit structure.
				Avoid INFP as SPEC, P(lle).
				Avoid INFP as SPEC, P(lle).
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [Ainf [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] + P(lle) = -98]
				[T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]] + P(lle) = -194]
				[[D heidän] [Ainf{v,V} D{N}]] + P(lle) = -94]
				[Ainf{v,V} D{N}] + P(lle) = -188]
				D{N} + P(lle) = 15]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D heidän] [Ainf{v,V} D{N}]]; P(lle)]
			3. [[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]; P(lle)]
			4. [[Ainf{v,V} D{N}]; P(lle)]
			5. [[T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]]

16.

		Consume "D"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]]

17.

		Consume "Merja-"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]

18.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v{V} [[D kirja] P(lle){D,N}]]]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [antaa [[D kirja] P(lle){D,N}]]]]]]]]
				Extracted head "D{N}" from P(lle) and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) D{N}]]]]]]]]]
			Reconstructing head movement for D{N}.
				Extracted head "Merja-" from D and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:16 [T/fin [<DP>:16 [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]
				= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]
			Dropping A-/A-bar movement.
				[D heidän] will undergo A-reconstruction (form of Agree).
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:16 [T/fin [<DP>:16 [käske [[D heidän]:17 [Ainf [(DP):17 [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:16 [T/fin [<DP>:16 [käske [[D heidän]:17 [Ainf [(DP):17 [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 10
['Pekka', 'nukkui', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'nukku-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "nukku"

		[[D Pekka] T/fin] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*nukku]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] T/fin{V}] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, malla.
				Considering T/fin{V} due to legitimate tail-head configuration.
				[[D Pekka] T/fin{V}] + malla = -98]
				T/fin{V} + malla = 206]
		Ranking completed:
			1. [T/fin{V}; malla]
			2. [[[D Pekka] T/fin{V}]; malla]
		Exploring solution number (1) =[T/fin{V} malla]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} malla]]

7.

		Consume "kuorsaa"

		[[D Pekka] [T/fin{V} malla]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [T/fin{V} malla{V}]]

8.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} malla{V}]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} malla{V}]].
				Extracted head "nukku" and reconstructed it = [[D Pekka] [T/fin [nukku malla{V}]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [T/fin [nukku [malla kuorsaa]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:3 [T/fin [<DP>:3 [nukku [malla kuorsaa]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [T/fin [<D Pekka> [nukku <malla kuorsaa>]]]]
			Dropping A-/A-bar movement.
			= [<D Pekka> [T/fin [<D Pekka> [nukku <malla kuorsaa>]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:3 [T/fin [<DP>:3 [nukku <malla kuorsaa>]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 11
['Pekka', 'hairitsee', 'Merjaa', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', '$v', 'hairitse-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "v"

		[[D Pekka] T/fin] + v
			Filtering out impossible merge sites...
			Sink "v" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*v]
			=[[D Pekka] T/fin{v}]

6.

		Consume "hairitsee"

		[[D Pekka] T/fin{v}] + hairitsee
			Filtering out impossible merge sites...
			Sink "hairitsee" into T/fin{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin{v}*hairitsee]
			=[[D Pekka] T/fin{v,V}]

7.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{v,V}]

8.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] T/fin{v,V}] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [v hairitsee]]]] D] due to bad left branch.
		Exploring solution number (1) =[T/fin{v,V} D]
			T/fin{v,V} cannot be opened.
			=[[D Pekka] [T/fin{v,V} D]]

9.

		Consume "Merjaa"

		[[D Pekka] [T/fin{v,V} D]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [T/fin{v,V} D{N}]]

10.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [T/fin{v,V} D{N}]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, malla.
				Avoid T/finP as SPEC, malla.
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T/fin [v [hairitsee [D Merjaa]]]] as left branch because it constitutes illicit structure.
				Considering D{N} due to legitimate tail-head configuration.
				[[D Pekka] [T/fin{v,V} D{N}]] + malla = -98]
				[T/fin{v,V} D{N}] + malla = -194]
				D{N} + malla = 209]
		Ranking completed:
			1. [D{N}; malla]
			2. [[[D Pekka] [T/fin{v,V} D{N}]]; malla]
			3. [[T/fin{v,V} D{N}]; malla]
		Exploring solution number (1) =[D{N} malla]
			D was opened.
			=[[D Pekka] [T/fin{v,V} [[D Merjaa] malla]]]

11.

		Consume "kuorsaa"

		[[D Pekka] [T/fin{v,V} [[D Merjaa] malla]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [T/fin{v,V} [[D Merjaa] malla{V}]]]

12.
	>>>	Trying candidate parse [[D Pekka] [T/fin{v,V} [[D Merjaa] malla{V}]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{v,V} [[D Merjaa] malla{V}]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [v{V} [[D Merjaa] malla{V}]]]]
				Extracted head "hairitsee" and reconstructed it = [[D Pekka] [T/fin [v [hairitsee [[D Merjaa] malla{V}]]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [T/fin [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:4 [T/fin [<DP>:4 [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [T/fin [<D Pekka> [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]
			Dropping A-/A-bar movement.
			= [<D Pekka> [T/fin [<D Pekka> [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:4 [T/fin [<DP>:4 [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 12
['Pekka', 'antoi', 'kirjan', 'Merjalle', 'heittamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', '$v', 'anta-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "v"

		[[D Pekka] T/fin] + v
			Filtering out impossible merge sites...
			Sink "v" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*v]
			=[[D Pekka] T/fin{v}]

6.

		Consume "antaa"

		[[D Pekka] T/fin{v}] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into T/fin{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin{v}*antaa]
			=[[D Pekka] T/fin{v,V}]

7.
		Next word contains multiple morphemes ['$asp', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:v,!COMP:*'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{v,V}]

8.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:v,!COMP:*', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:v,!COMP:*']

		Consume "D"

		[[D Pekka] T/fin{v,V}] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [v antaa]]]] D] due to bad left branch.
		Exploring solution number (1) =[T/fin{v,V} D]
			T/fin{v,V} cannot be opened.
			=[[D Pekka] [T/fin{v,V} D]]

9.

		Consume "kirja"

		[[D Pekka] [T/fin{v,V} D]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [T/fin{v,V} D{N}]]

10.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [T/fin{v,V} D{N}]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, P(lle).
				Avoid T/finP as SPEC, P(lle).
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T/fin [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [T/fin{v,V} D{N}]] + P(lle) = -98]
				[T/fin{v,V} D{N}] + P(lle) = -194]
				D{N} + P(lle) = 9]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D Pekka] [T/fin{v,V} D{N}]]; P(lle)]
			3. [[T/fin{v,V} D{N}]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [T/fin{v,V} [[D kirja] P(lle)]]]

11.

		Consume "D"

		[[D Pekka] [T/fin{v,V} [[D kirja] P(lle)]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D}]]]

12.

		Consume "Merja-"

		[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D}]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]]

13.
		Next word contains multiple morphemes ['$malla', 'heitta_pro-']

		Consume "malla"

		[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, malla.
				Avoid T/finP as SPEC, malla.
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T/fin [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]] as left branch because it constitutes illicit structure.
				[D kirja]" has no thematic role
				Avoid [[D kirja] [P(lle) [D Merja-]]] as left branch because it constitutes illicit structure.
				Considering [[D kirja] P(lle){D,N}] due to legitimate tail-head configuration.
				Avoid [P(lle){D,N} malla] due to complement selection.
				Considering P(lle){D,N} due to legitimate tail-head configuration.
				[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]] + malla = -98]
				[T/fin{v,V} [[D kirja] P(lle){D,N}]] + malla = -194]
				[[D kirja] P(lle){D,N}] + malla = 112]
				P(lle){D,N} + malla = 116]
		Ranking completed:
			1. [P(lle){D,N}; malla]
			2. [[[D kirja] P(lle){D,N}]; malla]
			3. [[[D Pekka] [T/fin{v,V} [[D kirja] P(lle){D,N}]]]; malla]
			4. [[T/fin{v,V} [[D kirja] P(lle){D,N}]]; malla]
		Exploring solution number (1) =[P(lle){D,N} malla]
			P(lle) was opened.
			=[[D Pekka] [T/fin{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]

14.

		Consume "heitta"

		[[D Pekka] [T/fin{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]] + heitta
			Filtering out impossible merge sites...
			Sink "heitta" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*heitta]
			=[[D Pekka] [T/fin{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]

15.
	>>>	Trying candidate parse [[D Pekka] [T/fin{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [v{V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [T/fin [v [antaa [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]
				Extracted head "heitta" from malla and created [[D Pekka] [T/fin [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:6 [T/fin [<DP>:6 [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]
				<malla heitta> was made an adjunct.
				= [<D Pekka> [T/fin [<D Pekka> [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]
			Dropping A-/A-bar movement.
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:6 [T/fin [<DP>:6 [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [T/fin [<D Pekka> [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:6 [T/fin [<DP>:6 [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 13
['Pekka', 'ei', 'nukkunut', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'nukku-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "nukku"

		[[D Pekka] [ei T]] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*nukku]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [ei T{V}]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, malla.
				Avoid Neg/finP as SPEC, malla.
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "nukku" lacks specifier D that it requires.
				Avoid [ei [T nukku]] as left branch because it constitutes illicit structure.
				[[D Pekka] [ei T{V}]] + malla = -98]
				[ei T{V}] + malla = -194]
				T{V} + malla = 3]
		Ranking completed:
			1. [T{V}; malla]
			2. [[[D Pekka] [ei T{V}]]; malla]
			3. [[ei T{V}]; malla]
		Exploring solution number (1) =[T{V} malla]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} malla]]]

8.

		Consume "kuorsaa"

		[[D Pekka] [ei [T{V} malla]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [ei [T{V} malla{V}]]]

9.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} malla{V}]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} malla{V}]]].
				Extracted head "nukku" and reconstructed it = [[D Pekka] [ei [T [nukku malla{V}]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [ei [T [nukku [malla kuorsaa]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:5 [ei [<DP>:5 [T [nukku [malla kuorsaa]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [ei [<D Pekka> [T [nukku <malla kuorsaa>]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:5 from memory buffer into Spec of nukku
				Result [<D Pekka>:5 [ei [<DP>:5 [T [<DP>:5 [nukku <malla kuorsaa>]]]]]]
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [nukku <malla kuorsaa>]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:5 [ei [<DP>:5 [T [<DP>:5 [nukku <malla kuorsaa>]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 14
['Pekka', 'ei', 'hairitse', 'Merjaa', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', '$v', 'hairitse-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "v"

		[[D Pekka] [ei T]] + v
			Filtering out impossible merge sites...
			Sink "v" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*v]
			=[[D Pekka] [ei T{v}]]

7.

		Consume "hairitsee"

		[[D Pekka] [ei T{v}]] + hairitsee
			Filtering out impossible merge sites...
			Sink "hairitsee" into T{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T{v}*hairitsee]
			=[[D Pekka] [ei T{v,V}]]

8.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{v,V}]]

9.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei T{v,V}]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v hairitsee]]]]]] D] due to bad left branch.
				Reject [[ei [T [v hairitsee]]] D] due to bad left branch.
		Exploring solution number (1) =[T{v,V} D]
			T{v,V} cannot be opened.
			=[[D Pekka] [ei [T{v,V} D]]]

10.

		Consume "Merjaa"

		[[D Pekka] [ei [T{v,V} D]]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [ei [T{v,V} D{N}]]]

11.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [ei [T{v,V} D{N}]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, malla.
				Avoid Neg/finP as SPEC, malla.
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [ei [T [v [hairitsee [D Merjaa]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T [v [hairitsee [D Merjaa]]]] as left branch because it constitutes illicit structure.
				[[D Pekka] [ei [T{v,V} D{N}]]] + malla = -98]
				[ei [T{v,V} D{N}]] + malla = -194]
				[T{v,V} D{N}] + malla = -94]
				D{N} + malla = 4]
		Ranking completed:
			1. [D{N}; malla]
			2. [[T{v,V} D{N}]; malla]
			3. [[[D Pekka] [ei [T{v,V} D{N}]]]; malla]
			4. [[ei [T{v,V} D{N}]]; malla]
		Exploring solution number (1) =[D{N} malla]
			D was opened.
			=[[D Pekka] [ei [T{v,V} [[D Merjaa] malla]]]]

12.

		Consume "kuorsaa"

		[[D Pekka] [ei [T{v,V} [[D Merjaa] malla]]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [ei [T{v,V} [[D Merjaa] malla{V}]]]]

13.
	>>>	Trying candidate parse [[D Pekka] [ei [T{v,V} [[D Merjaa] malla{V}]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{v,V} [[D Merjaa] malla{V}]]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [v{V} [[D Merjaa] malla{V}]]]]]
				Extracted head "hairitsee" and reconstructed it = [[D Pekka] [ei [T [v [hairitsee [[D Merjaa] malla{V}]]]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [ei [T [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:7 [ei [<DP>:7 [T [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [ei [<D Pekka> [T [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:7 from memory buffer into Spec of v
				Result [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 15
['Pekka', 'ei', 'antanut', 'kirjaa', 'Merjalle', 'heittamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', '$v', 'anta-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "v"

		[[D Pekka] [ei T]] + v
			Filtering out impossible merge sites...
			Sink "v" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*v]
			=[[D Pekka] [ei T{v}]]

7.

		Consume "antaa"

		[[D Pekka] [ei T{v}]] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into T{v} because they are inside the same phonological word.
		Exploring solution number (1) =[T{v}*antaa]
			=[[D Pekka] [ei T{v,V}]]

8.
		Next word contains multiple morphemes ['$par', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{v,V}]]

9.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei T{v,V}]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v antaa]]]]]] D] due to bad left branch.
				Reject [[ei [T [v antaa]]] D] due to bad left branch.
		Exploring solution number (1) =[T{v,V} D]
			T{v,V} cannot be opened.
			=[[D Pekka] [ei [T{v,V} D]]]

10.

		Consume "kirja"

		[[D Pekka] [ei [T{v,V} D]]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [ei [T{v,V} D{N}]]]

11.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [ei [T{v,V} D{N}]]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, P(lle).
				Avoid Neg/finP as SPEC, P(lle).
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [ei [T [v [antaa [D kirja]]]]] as left branch because it constitutes illicit structure.
				Avoid [[T{v,V} D{N}], P(lle)] because the operation breaks up an existing selectional dependency.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [T [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [ei [T{v,V} D{N}]]] + P(lle) = -98]
				[ei [T{v,V} D{N}]] + P(lle) = -194]
				[T{v,V} D{N}] + P(lle) = -191]
				D{N} + P(lle) = 12]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D Pekka] [ei [T{v,V} D{N}]]]; P(lle)]
			3. [[T{v,V} D{N}]; P(lle)]
			4. [[ei [T{v,V} D{N}]]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [ei [T{v,V} [[D kirja] P(lle)]]]]

12.

		Consume "D"

		[[D Pekka] [ei [T{v,V} [[D kirja] P(lle)]]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D}]]]]

13.

		Consume "Merja-"

		[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D}]]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]]

14.
		Next word contains multiple morphemes ['$malla', 'heitta_pro-']

		Consume "malla"

		[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, malla.
				Avoid Neg/finP as SPEC, malla.
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [ei [T [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "v" lacks specifier D that it requires.
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Avoid [T [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]] as left branch because it constitutes illicit structure.
				[D kirja]" has no thematic role
				Avoid [[D kirja] [P(lle) [D Merja-]]] as left branch because it constitutes illicit structure.
				Avoid [P(lle){D,N} malla] due to complement selection.
			P(lle) was opened.
				Prioritize P(lle){D,N} because all solutions were negative.
				[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]] + malla = -98]
				[ei [T{v,V} [[D kirja] P(lle){D,N}]]] + malla = -194]
				[T{v,V} [[D kirja] P(lle){D,N}]] + malla = -94]
				[[D kirja] P(lle){D,N}] + malla = -92]
				P(lle){D,N} + malla = 110]
		Ranking completed:
			1. [P(lle){D,N}; malla]
			2. [[[D kirja] P(lle){D,N}]; malla]
			3. [[T{v,V} [[D kirja] P(lle){D,N}]]; malla]
			4. [[[D Pekka] [ei [T{v,V} [[D kirja] P(lle){D,N}]]]]; malla]
			5. [[ei [T{v,V} [[D kirja] P(lle){D,N}]]]; malla]
		Exploring solution number (1) =[P(lle){D,N} malla]
			P(lle) was opened.
			=[[D Pekka] [ei [T{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]]

15.

		Consume "heitta"

		[[D Pekka] [ei [T{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]] + heitta
			Filtering out impossible merge sites...
			Sink "heitta" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*heitta]
			=[[D Pekka] [ei [T{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]

16.
	>>>	Trying candidate parse [[D Pekka] [ei [T{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]].
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [v{V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [ei [T [v [antaa [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]
				Extracted head "heitta" from malla and created [[D Pekka] [ei [T [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:11 [ei [<DP>:11 [T [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]]
				<malla heitta> was made an adjunct.
				= [<D Pekka> [ei [<D Pekka> [T [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:11 from memory buffer into Spec of v
				Result [<D Pekka>:11 [ei [<DP>:11 [T [<DP>:11 [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]]
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:11 [ei [<DP>:11 [T [<DP>:11 [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:11 [ei [<DP>:11 [T [<DP>:11 [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 16
['Pekka', 'ei', 'kaskenyt', 'heidan', 'nukkua']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'kaske-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "käske"

		[[D Pekka] [ei T]] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*käske]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{V}]]

8.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] [ei T{V}]] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [ei [<D Pekka> [T [<D Pekka> käske]]]]] as left branch because it constitutes illicit structure.
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				An EPP-head "ei" lacks specifier but needs one.
				käske (käske) is missing complement A/inf
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T käske]] as left branch because it constitutes illicit structure.
				Avoid TP as SPEC for D due to unselective SPEC feature.
				Avoid [T{V} D] due to local agreement failure.
				Prioritize [T{V} D] due to complement selection.
				[[D Pekka] [ei T{V}]] + D = -197]
				[ei T{V}] + D = -194]
				T{V} + D = -38]
		Ranking completed:
			1. [T{V}; D]
			2. [[ei T{V}]; D]
			3. [[[D Pekka] [ei T{V}]]; D]
		Exploring solution number (1) =[T{V} D]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} D]]]

9.

		Consume "heidän"

		[[D Pekka] [ei [T{V} D]]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [ei [T{V} D{N}]]]

10.
		Next word contains multiple morphemes ['$-ta', 'nukku-']

		Consume "Ainf"

		[[D Pekka] [ei [T{V} D{N}]]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske <D heidän>]]]]]] Ainf] due to bad left branch.
				Reject [[ei [T [käske <D heidän>]]] Ainf] due to bad left branch.
				Reject [[T [käske [D heidän]]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]]

11.

		Consume "nukku"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*nukku]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]]

12.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] Ainf{V}]]]]]
				Extracted head "nukku" from Ainf and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf nukku]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:7 [ei [<DP>:7 [T [käske [[D heidän] [Ainf nukku]]]]]]]
				= [<D Pekka> [ei [<D Pekka> [T [käske [[D heidän] [Ainf nukku]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:7 from memory buffer into Spec of käske
				Result [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [käske [[D heidän] [Ainf nukku]]]]]]]]
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] nukku]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:7 [ei [<DP>:7 [T [<DP>:7 [käske [[D heidän]:9 [Ainf [(DP):9 nukku]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 17
['Pekka', 'ei', 'kaskenyt', 'heidan', 'ihailla', 'Merjaa']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'kaske-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "käske"

		[[D Pekka] [ei T]] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*käske]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{V}]]

8.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] [ei T{V}]] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [ei [<D Pekka> [T [<D Pekka> käske]]]]] as left branch because it constitutes illicit structure.
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				An EPP-head "ei" lacks specifier but needs one.
				käske (käske) is missing complement A/inf
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T käske]] as left branch because it constitutes illicit structure.
				Avoid TP as SPEC for D due to unselective SPEC feature.
				Avoid [T{V} D] due to local agreement failure.
				Prioritize [T{V} D] due to complement selection.
				[[D Pekka] [ei T{V}]] + D = -197]
				[ei T{V}] + D = -194]
				T{V} + D = -38]
		Ranking completed:
			1. [T{V}; D]
			2. [[ei T{V}]; D]
			3. [[[D Pekka] [ei T{V}]]; D]
		Exploring solution number (1) =[T{V} D]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} D]]]

9.

		Consume "heidän"

		[[D Pekka] [ei [T{V} D]]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [ei [T{V} D{N}]]]

10.
		Next word contains multiple morphemes ['$-ta', '$v', 'ihaile-']

		Consume "Ainf"

		[[D Pekka] [ei [T{V} D{N}]]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske <D heidän>]]]]]] Ainf] due to bad left branch.
				Reject [[ei [T [käske <D heidän>]]] Ainf] due to bad left branch.
				Reject [[T [käske [D heidän]]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]]

11.

		Consume "v"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]]

12.

		Consume "ihailee"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]] + ihailee
			Filtering out impossible merge sites...
			Sink "ihailee" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*ihailee]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

13.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

14.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v ihailee]]]]]]]]]] D] due to bad left branch.
				Reject [[ei [T [käske [[D heidän] [Ainf [[D heidän] [v ihailee]]]]]]] D] due to bad left branch.
				Reject [[T [käske [[D heidän] [Ainf [[D heidän] [v ihailee]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v ihailee]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]]

15.

		Consume "Merjaa"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]

16.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf{v,V} D{N}]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v{V} D{N}]]]]]]]
				Extracted head "ihailee" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [ihailee D{N}]]]]]]]]
				Extracted head "Merjaa" from D and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:13 [ei [<DP>:13 [T [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]]]
				= [<D Pekka> [ei [<D Pekka> [T [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:13 from memory buffer into Spec of käske
				Result [<D Pekka>:13 [ei [<DP>:13 [T [<DP>:13 [käske [[D heidän] [Ainf [v [ihailee [D Merjaa]]]]]]]]]]]
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [ihailee [D Merjaa]]]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:13 [ei [<DP>:13 [T [<DP>:13 [käske [[D heidän]:15 [Ainf [(DP):15 [v [ihailee [D Merjaa]]]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 18
['Pekka', 'ei', 'kaskenyt', 'heidan', 'antaa', 'kirjaa', 'Merjalle']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'kaske-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "käske"

		[[D Pekka] [ei T]] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*käske]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{V}]]

8.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] [ei T{V}]] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [ei [<D Pekka> [T [<D Pekka> käske]]]]] as left branch because it constitutes illicit structure.
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				An EPP-head "ei" lacks specifier but needs one.
				käske (käske) is missing complement A/inf
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T käske]] as left branch because it constitutes illicit structure.
				Avoid TP as SPEC for D due to unselective SPEC feature.
				Avoid [T{V} D] due to local agreement failure.
				Prioritize [T{V} D] due to complement selection.
				[[D Pekka] [ei T{V}]] + D = -197]
				[ei T{V}] + D = -194]
				T{V} + D = -38]
		Ranking completed:
			1. [T{V}; D]
			2. [[ei T{V}]; D]
			3. [[[D Pekka] [ei T{V}]]; D]
		Exploring solution number (1) =[T{V} D]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} D]]]

9.

		Consume "heidän"

		[[D Pekka] [ei [T{V} D]]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [ei [T{V} D{N}]]]

10.
		Next word contains multiple morphemes ['$-ta', '$v', 'anta-']

		Consume "Ainf"

		[[D Pekka] [ei [T{V} D{N}]]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske <D heidän>]]]]]] Ainf] due to bad left branch.
				Reject [[ei [T [käske <D heidän>]]] Ainf] due to bad left branch.
				Reject [[T [käske [D heidän]]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]]

11.

		Consume "v"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]]

12.

		Consume "antaa"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*antaa]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

13.
		Next word contains multiple morphemes ['$par', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

14.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]]]]]] D] due to bad left branch.
				Reject [[ei [T [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]]] D] due to bad left branch.
				Reject [[T [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v antaa]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]]

15.

		Consume "kirja"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]

16.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, P(lle).
				Avoid Neg/finP as SPEC, P(lle).
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T [käske [[D heidän] [Ainf [[D heidän] [v [antaa [D kirja]]]]]]]]] as left branch because it constitutes illicit structure.
				Avoid [[T{V} [[D heidän] [Ainf{v,V} D{N}]]], P(lle)] because the operation breaks up an existing selectional dependency.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T [käske [[D heidän] [Ainf [[D heidän] [v [antaa [D kirja]]]]]]]] as left branch because it constitutes illicit structure.
				Avoid INFP as SPEC, P(lle).
				Avoid INFP as SPEC, P(lle).
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [Ainf [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] + P(lle) = -98]
				[ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]] + P(lle) = -194]
				[T{V} [[D heidän] [Ainf{v,V} D{N}]]] + P(lle) = -191]
				[[D heidän] [Ainf{v,V} D{N}]] + P(lle) = -92]
				[Ainf{v,V} D{N}] + P(lle) = -185]
				D{N} + P(lle) = 18]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D heidän] [Ainf{v,V} D{N}]]; P(lle)]
			3. [[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]; P(lle)]
			4. [[Ainf{v,V} D{N}]; P(lle)]
			5. [[T{V} [[D heidän] [Ainf{v,V} D{N}]]]; P(lle)]
			6. [[ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]]]

17.

		Consume "D"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]]]

18.

		Consume "Merja-"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]]

19.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v{V} [[D kirja] P(lle){D,N}]]]]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] P(lle){D,N}]]]]]]]]]
				Extracted head "D{N}" from P(lle) and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) D{N}]]]]]]]]]]
			Reconstructing head movement for D{N}.
				Extracted head "Merja-" from D and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:25 [ei [<DP>:25 [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]]
				= [<D Pekka> [ei [<D Pekka> [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:25 from memory buffer into Spec of käske
				Result [<D Pekka>:25 [ei [<DP>:25 [T [<DP>:25 [käske [[D heidän] [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]]]
				[D heidän] will undergo A-reconstruction (form of Agree).
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:25 [ei [<DP>:25 [T [<DP>:25 [käske [[D heidän]:27 [Ainf [(DP):27 [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:25 [ei [<DP>:25 [T [<DP>:25 [käske [[D heidän]:27 [Ainf [(DP):27 [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 19
['Pekka', 'kaski', 'heidan', 'nukkua', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'kaske-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "käske"

		[[D Pekka] T/fin] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*käske]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{V}]

7.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] T/fin{V}] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [T/fin [<D Pekka> käske]]] as left branch because it constitutes illicit structure.
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				Avoid [T/fin{V} D] due to local agreement failure.
				Prioritize [T/fin{V} D] due to complement selection.
				[[D Pekka] T/fin{V}] + D = -197]
				T/fin{V} + D = -42]
		Ranking completed:
			1. [T/fin{V}; D]
			2. [[[D Pekka] T/fin{V}]; D]
		Exploring solution number (1) =[T/fin{V} D]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} D]]

8.

		Consume "heidän"

		[[D Pekka] [T/fin{V} D]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [T/fin{V} D{N}]]

9.
		Next word contains multiple morphemes ['$-ta', 'nukku-']

		Consume "Ainf"

		[[D Pekka] [T/fin{V} D{N}]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske <D heidän>]]]] Ainf] due to bad left branch.
				Reject [[T/fin [käske <D heidän>]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf]]]

10.

		Consume "nukku"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf]]] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*nukku]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]]

11.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, malla.
				Avoid T/finP as SPEC, malla.
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T/fin [käske [[D heidän] [Ainf [[D heidän] nukku]]]]] as left branch because it constitutes illicit structure.
				Considering [[D heidän] Ainf{V}] due to legitimate tail-head configuration.
				Considering Ainf{V} due to legitimate tail-head configuration.
				[[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]] + malla = -98]
				[T/fin{V} [[D heidän] Ainf{V}]] + malla = -194]
				[[D heidän] Ainf{V}] + malla = 209]
				Ainf{V} + malla = 212]
		Ranking completed:
			1. [Ainf{V}; malla]
			2. [[[D heidän] Ainf{V}]; malla]
			3. [[[D Pekka] [T/fin{V} [[D heidän] Ainf{V}]]]; malla]
			4. [[T/fin{V} [[D heidän] Ainf{V}]]; malla]
		Exploring solution number (1) =[Ainf{V} malla]
			Ainf{V} cannot be opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{V} malla]]]]

12.

		Consume "kuorsaa"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{V} malla]]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{V} malla{V}]]]]

13.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} [[D heidän] [Ainf{V} malla{V}]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} [[D heidän] [Ainf{V} malla{V}]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf{V} malla{V}]]]]]
				Extracted head "nukku" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [nukku malla{V}]]]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf [nukku [malla kuorsaa]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:12 [T/fin [<DP>:12 [käske [[D heidän] [Ainf [nukku [malla kuorsaa]]]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [nukku <malla kuorsaa>]]]]]]]
			Dropping A-/A-bar movement.
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [nukku <malla kuorsaa>]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:12 [T/fin [<DP>:12 [käske [[D heidän]:13 [Ainf [(DP):13 [nukku <malla kuorsaa>]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 20
['Pekka', 'kaski', 'heidan', 'hairita', 'Merjaa', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'kaske-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "käske"

		[[D Pekka] T/fin] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*käske]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{V}]

7.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] T/fin{V}] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [T/fin [<D Pekka> käske]]] as left branch because it constitutes illicit structure.
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				Avoid [T/fin{V} D] due to local agreement failure.
				Prioritize [T/fin{V} D] due to complement selection.
				[[D Pekka] T/fin{V}] + D = -197]
				T/fin{V} + D = -42]
		Ranking completed:
			1. [T/fin{V}; D]
			2. [[[D Pekka] T/fin{V}]; D]
		Exploring solution number (1) =[T/fin{V} D]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} D]]

8.

		Consume "heidän"

		[[D Pekka] [T/fin{V} D]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [T/fin{V} D{N}]]

9.
		Next word contains multiple morphemes ['$-ta', '$v', 'hairitse-']

		Consume "Ainf"

		[[D Pekka] [T/fin{V} D{N}]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske <D heidän>]]]] Ainf] due to bad left branch.
				Reject [[T/fin [käske <D heidän>]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf]]]

10.

		Consume "v"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]]

11.

		Consume "hairitsee"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]] + hairitsee
			Filtering out impossible merge sites...
			Sink "hairitsee" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*hairitsee]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

12.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

13.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v hairitsee]]]]]]]] D] due to bad left branch.
				Reject [[T/fin [käske [[D heidän] [Ainf [[D heidän] [v hairitsee]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v hairitsee]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]]

14.

		Consume "Merjaa"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]

15.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, malla.
				Avoid T/finP as SPEC, malla.
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T/fin [käske [[D heidän] [Ainf [[D heidän] [v [hairitsee [D Merjaa]]]]]]]] as left branch because it constitutes illicit structure.
				Considering [[D heidän] [Ainf{v,V} D{N}]] due to legitimate tail-head configuration.
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [Ainf [v [hairitsee [D Merjaa]]]] as left branch because it constitutes illicit structure.
				Considering [Ainf{v,V} D{N}] due to legitimate tail-head configuration.
				Considering D{N} due to legitimate tail-head configuration.
				[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] + malla = -98]
				[T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]] + malla = -194]
				[[D heidän] [Ainf{v,V} D{N}]] + malla = 209]
				[Ainf{v,V} D{N}] + malla = 116]
				D{N} + malla = 215]
		Ranking completed:
			1. [D{N}; malla]
			2. [[[D heidän] [Ainf{v,V} D{N}]]; malla]
			3. [[Ainf{v,V} D{N}]; malla]
			4. [[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]; malla]
			5. [[T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]; malla]
		Exploring solution number (1) =[D{N} malla]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla]]]]]

16.

		Consume "kuorsaa"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla]]]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]]

17.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v{V} [[D Merjaa] malla{V}]]]]]]]
				Extracted head "hairitsee" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] malla{V}]]]]]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:16 [T/fin [<DP>:16 [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]
			Dropping A-/A-bar movement.
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:16 [T/fin [<DP>:16 [käske [[D heidän]:17 [Ainf [(DP):17 [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 21
['Pekka', 'kaski', 'heidan', 'antaa', 'kirjan', 'Merjalle', 'heittamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.
		Next word contains multiple morphemes ['$T/fin', 'kaske-']

		Consume "T/fin"

		D{N} + T/fin
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} T/fin]
			D was opened.
			=[[D Pekka] T/fin]

5.

		Consume "käske"

		[[D Pekka] T/fin] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T/fin because they are inside the same phonological word.
		Exploring solution number (1) =[T/fin*käske]
			=[[D Pekka] T/fin{V}]

6.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] T/fin{V}]

7.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] T/fin{V}] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [T/fin [<D Pekka> käske]]] as left branch because it constitutes illicit structure.
				Avoid T/finP as SPEC for D due to unselective SPEC feature.
				Avoid [T/fin{V} D] due to local agreement failure.
				Prioritize [T/fin{V} D] due to complement selection.
				[[D Pekka] T/fin{V}] + D = -197]
				T/fin{V} + D = -42]
		Ranking completed:
			1. [T/fin{V}; D]
			2. [[[D Pekka] T/fin{V}]; D]
		Exploring solution number (1) =[T/fin{V} D]
			T/fin{V} cannot be opened.
			=[[D Pekka] [T/fin{V} D]]

8.

		Consume "heidän"

		[[D Pekka] [T/fin{V} D]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [T/fin{V} D{N}]]

9.
		Next word contains multiple morphemes ['$-ta', '$v', 'anta-']

		Consume "Ainf"

		[[D Pekka] [T/fin{V} D{N}]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske <D heidän>]]]] Ainf] due to bad left branch.
				Reject [[T/fin [käske <D heidän>]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf]]]

10.

		Consume "v"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]]

11.

		Consume "antaa"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v}]]] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*antaa]
			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

12.
		Next word contains multiple morphemes ['$asp', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:v,!COMP:*'] into working memory.

		Consume "$D"

			=[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]]

13.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:v,!COMP:*', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:v,!COMP:*']

		Consume "D"

		[[D Pekka] [T/fin{V} [[D heidän] Ainf{v,V}]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]]]] D] due to bad left branch.
				Reject [[T/fin [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v antaa]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]]

14.

		Consume "kirja"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D]]]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]

15.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, P(lle).
				Avoid T/finP as SPEC, P(lle).
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T/fin [käske [[D heidän] [Ainf [[D heidän] [v [antaa [D kirja]]]]]]]] as left branch because it constitutes illicit structure.
				Avoid INFP as SPEC, P(lle).
				Avoid INFP as SPEC, P(lle).
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [Ainf [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]] + P(lle) = -98]
				[T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]] + P(lle) = -194]
				[[D heidän] [Ainf{v,V} D{N}]] + P(lle) = -94]
				[Ainf{v,V} D{N}] + P(lle) = -188]
				D{N} + P(lle) = 15]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D heidän] [Ainf{v,V} D{N}]]; P(lle)]
			3. [[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]]; P(lle)]
			4. [[Ainf{v,V} D{N}]; P(lle)]
			5. [[T/fin{V} [[D heidän] [Ainf{v,V} D{N}]]]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]]

16.

		Consume "D"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]]

17.

		Consume "Merja-"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]

18.
		Next word contains multiple morphemes ['$malla', 'heitta_pro-']

		Consume "malla"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid T/finP as SPEC, malla.
				Avoid T/finP as SPEC, malla.
				An EPP-head "T/fin" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T/fin [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]] as left branch because it constitutes illicit structure.
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Avoid [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]] as left branch because it constitutes illicit structure.
				Considering [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]] due to legitimate tail-head configuration.
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Avoid [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]] as left branch because it constitutes illicit structure.
				Considering [Ainf{v,V} [[D kirja] P(lle){D,N}]] due to legitimate tail-head configuration.
				[D kirja]" has no thematic role
				Avoid [[D kirja] [P(lle) [D Merja-]]] as left branch because it constitutes illicit structure.
				Considering [[D kirja] P(lle){D,N}] due to legitimate tail-head configuration.
				Avoid [P(lle){D,N} malla] due to complement selection.
				Considering P(lle){D,N} due to legitimate tail-head configuration.
				[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]] + malla = -98]
				[T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]] + malla = -194]
				[[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]] + malla = 112]
				[Ainf{v,V} [[D kirja] P(lle){D,N}]] + malla = 116]
				[[D kirja] P(lle){D,N}] + malla = 120]
				P(lle){D,N} + malla = 124]
		Ranking completed:
			1. [P(lle){D,N}; malla]
			2. [[[D kirja] P(lle){D,N}]; malla]
			3. [[Ainf{v,V} [[D kirja] P(lle){D,N}]]; malla]
			4. [[[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]; malla]
			5. [[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]; malla]
			6. [[T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]; malla]
		Exploring solution number (1) =[P(lle){D,N} malla]
			P(lle) was opened.
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]]]

19.

		Consume "heitta"

		[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]]] + heitta
			Filtering out impossible merge sites...
			Sink "heitta" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*heitta]
			=[[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]

20.
	>>>	Trying candidate parse [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [T/fin{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v{V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]]]
				Extracted head "heitta" from malla and created [[D Pekka] [T/fin [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:24 [T/fin [<DP>:24 [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]]]]
				<malla heitta> was made an adjunct.
				= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]]]
			Dropping A-/A-bar movement.
				[D heidän] will undergo A-reconstruction (form of Agree).
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:24 [T/fin [<DP>:24 [käske [[D heidän]:25 [Ainf [(DP):25 [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [T/fin [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:24 [T/fin [<DP>:24 [käske [[D heidän]:25 [Ainf [(DP):25 [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 22
['Pekka', 'ei', 'kaskenyt', 'heidan', 'nukkua', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'kaske-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "käske"

		[[D Pekka] [ei T]] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*käske]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{V}]]

8.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] [ei T{V}]] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [ei [<D Pekka> [T [<D Pekka> käske]]]]] as left branch because it constitutes illicit structure.
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				An EPP-head "ei" lacks specifier but needs one.
				käske (käske) is missing complement A/inf
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T käske]] as left branch because it constitutes illicit structure.
				Avoid TP as SPEC for D due to unselective SPEC feature.
				Avoid [T{V} D] due to local agreement failure.
				Prioritize [T{V} D] due to complement selection.
				[[D Pekka] [ei T{V}]] + D = -197]
				[ei T{V}] + D = -194]
				T{V} + D = -38]
		Ranking completed:
			1. [T{V}; D]
			2. [[ei T{V}]; D]
			3. [[[D Pekka] [ei T{V}]]; D]
		Exploring solution number (1) =[T{V} D]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} D]]]

9.

		Consume "heidän"

		[[D Pekka] [ei [T{V} D]]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [ei [T{V} D{N}]]]

10.
		Next word contains multiple morphemes ['$-ta', 'nukku-']

		Consume "Ainf"

		[[D Pekka] [ei [T{V} D{N}]]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske <D heidän>]]]]]] Ainf] due to bad left branch.
				Reject [[ei [T [käske <D heidän>]]] Ainf] due to bad left branch.
				Reject [[T [käske [D heidän]]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]]

11.

		Consume "nukku"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]] + nukku
			Filtering out impossible merge sites...
			Sink "nukku" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*nukku]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]]

12.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, malla.
				Avoid Neg/finP as SPEC, malla.
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T [käske [[D heidän] [Ainf [[D heidän] nukku]]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T [käske [[D heidän] [Ainf [[D heidän] nukku]]]]] as left branch because it constitutes illicit structure.
				[[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]] + malla = -98]
				[ei [T{V} [[D heidän] Ainf{V}]]] + malla = -194]
				[T{V} [[D heidän] Ainf{V}]] + malla = -94]
				[[D heidän] Ainf{V}] + malla = 4]
				Ainf{V} + malla = 5]
		Ranking completed:
			1. [Ainf{V}; malla]
			2. [[[D heidän] Ainf{V}]; malla]
			3. [[T{V} [[D heidän] Ainf{V}]]; malla]
			4. [[[D Pekka] [ei [T{V} [[D heidän] Ainf{V}]]]]; malla]
			5. [[ei [T{V} [[D heidän] Ainf{V}]]]; malla]
		Exploring solution number (1) =[Ainf{V} malla]
			Ainf{V} cannot be opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{V} malla]]]]]

13.

		Consume "kuorsaa"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{V} malla]]]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{V} malla{V}]]]]]

14.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} [[D heidän] [Ainf{V} malla{V}]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} [[D heidän] [Ainf{V} malla{V}]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf{V} malla{V}]]]]]]
				Extracted head "nukku" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [nukku malla{V}]]]]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf [nukku [malla kuorsaa]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:19 [ei [<DP>:19 [T [käske [[D heidän] [Ainf [nukku [malla kuorsaa]]]]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [ei [<D Pekka> [T [käske [[D heidän] [Ainf [nukku <malla kuorsaa>]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:19 from memory buffer into Spec of käske
				Result [<D Pekka>:19 [ei [<DP>:19 [T [<DP>:19 [käske [[D heidän] [Ainf [nukku <malla kuorsaa>]]]]]]]]]
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [nukku <malla kuorsaa>]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:19 [ei [<DP>:19 [T [<DP>:19 [käske [[D heidän]:21 [Ainf [(DP):21 [nukku <malla kuorsaa>]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 23
['Pekka', 'ei', 'kaskenyt', 'heidan', 'hairita', 'Merjaa', 'kuorsaamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'kaske-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "käske"

		[[D Pekka] [ei T]] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*käske]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{V}]]

8.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] [ei T{V}]] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [ei [<D Pekka> [T [<D Pekka> käske]]]]] as left branch because it constitutes illicit structure.
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				An EPP-head "ei" lacks specifier but needs one.
				käske (käske) is missing complement A/inf
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T käske]] as left branch because it constitutes illicit structure.
				Avoid TP as SPEC for D due to unselective SPEC feature.
				Avoid [T{V} D] due to local agreement failure.
				Prioritize [T{V} D] due to complement selection.
				[[D Pekka] [ei T{V}]] + D = -197]
				[ei T{V}] + D = -194]
				T{V} + D = -38]
		Ranking completed:
			1. [T{V}; D]
			2. [[ei T{V}]; D]
			3. [[[D Pekka] [ei T{V}]]; D]
		Exploring solution number (1) =[T{V} D]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} D]]]

9.

		Consume "heidän"

		[[D Pekka] [ei [T{V} D]]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [ei [T{V} D{N}]]]

10.
		Next word contains multiple morphemes ['$-ta', '$v', 'hairitse-']

		Consume "Ainf"

		[[D Pekka] [ei [T{V} D{N}]]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske <D heidän>]]]]]] Ainf] due to bad left branch.
				Reject [[ei [T [käske <D heidän>]]] Ainf] due to bad left branch.
				Reject [[T [käske [D heidän]]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]]

11.

		Consume "v"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]]

12.

		Consume "hairitsee"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]] + hairitsee
			Filtering out impossible merge sites...
			Sink "hairitsee" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*hairitsee]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

13.
		Next word contains multiple morphemes ['$par', '$D', 'Merjaa-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

14.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v hairitsee]]]]]]]]]] D] due to bad left branch.
				Reject [[ei [T [käske [[D heidän] [Ainf [[D heidän] [v hairitsee]]]]]]] D] due to bad left branch.
				Reject [[T [käske [[D heidän] [Ainf [[D heidän] [v hairitsee]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v hairitsee]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]]

15.

		Consume "Merjaa"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]] + Merjaa
			Filtering out impossible merge sites...
			Sink "Merjaa" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Merjaa]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]

16.
		Next word contains multiple morphemes ['$malla', 'kuorsaa_pro-']

		Consume "malla"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, malla.
				Avoid Neg/finP as SPEC, malla.
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T [käske [[D heidän] [Ainf [[D heidän] [v [hairitsee [D Merjaa]]]]]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T [käske [[D heidän] [Ainf [[D heidän] [v [hairitsee [D Merjaa]]]]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [Ainf [v [hairitsee [D Merjaa]]]] as left branch because it constitutes illicit structure.
				[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] + malla = -98]
				[ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]] + malla = -194]
				[T{V} [[D heidän] [Ainf{v,V} D{N}]]] + malla = -94]
				[[D heidän] [Ainf{v,V} D{N}]] + malla = 4]
				[Ainf{v,V} D{N}] + malla = -90]
				D{N} + malla = 6]
		Ranking completed:
			1. [D{N}; malla]
			2. [[[D heidän] [Ainf{v,V} D{N}]]; malla]
			3. [[Ainf{v,V} D{N}]; malla]
			4. [[T{V} [[D heidän] [Ainf{v,V} D{N}]]]; malla]
			5. [[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]; malla]
			6. [[ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]; malla]
		Exploring solution number (1) =[D{N} malla]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla]]]]]]

17.

		Consume "kuorsaa"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla]]]]]] + kuorsaa
			Filtering out impossible merge sites...
			Sink "kuorsaa" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*kuorsaa]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]]]

18.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf{v,V} [[D Merjaa] malla{V}]]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v{V} [[D Merjaa] malla{V}]]]]]]]]
				Extracted head "hairitsee" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] malla{V}]]]]]]]]]
				Extracted head "kuorsaa" from malla and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:25 [ei [<DP>:25 [T [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] [malla kuorsaa]]]]]]]]]]]
				<malla kuorsaa> was made an adjunct.
				= [<D Pekka> [ei [<D Pekka> [T [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:25 from memory buffer into Spec of käske
				Result [<D Pekka>:25 [ei [<DP>:25 [T [<DP>:25 [käske [[D heidän] [Ainf [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]]]
				[D heidän] will undergo A-reconstruction (form of Agree).
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:25 [ei [<DP>:25 [T [<DP>:25 [käske [[D heidän]:27 [Ainf [(DP):27 [v [hairitsee [[D Merjaa] <malla kuorsaa>]]]]]]]]]]]] into LF...
				Transfer to LF successful.


\========================================================================
# 24
['Pekka', 'ei', 'kaskenyt', 'heidan', 'antaa', 'kirjaa', 'Merjalle', 'heittamalla']


			=None

1.
		Next word contains multiple morphemes ['$nom', '$D', 'Pekka-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:CAT:FIN,A/HEAD'] into working memory.

		Consume "$D"

			=None

2.

		Adding inflectional features {'LANG:FI', 'TAIL:CAT:FIN,A/HEAD', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:FIN,A/HEAD']
			=D

3.

		Consume "Pekka"

		D + Pekka
			Filtering out impossible merge sites...
			Sink "Pekka" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*Pekka]
			=D{N}

4.

		Consume "ei"

		D{N} + ei
			Filtering out impossible merge sites...
		Exploring solution number (1) =[D{N} ei]
			D was opened.
			=[[D Pekka] ei]

5.
		Next word contains multiple morphemes ['$T', 'kaske-']

		Consume "T"

		[[D Pekka] ei] + T
			Filtering out impossible merge sites...
				Reject [[[D Pekka] ei] T] due to bad left branch.
		Exploring solution number (1) =[ei T]
			Reconstructing head movement for ei.
			Dropping floaters...
				= ei
			Dropping A-/A-bar movement.
				ei (ei) is missing complement T
				An EPP-head "ei" lacks specifier but needs one.
				Extraposition will be tried on ei.
			=[[D Pekka] [ei T]]

6.

		Consume "käske"

		[[D Pekka] [ei T]] + käske
			Filtering out impossible merge sites...
			Sink "käske" into T because they are inside the same phonological word.
		Exploring solution number (1) =[T*käske]
			=[[D Pekka] [ei T{V}]]

7.
		Next word contains multiple morphemes ['$gen', '$D', 'heidan-']
		Storing inflectional feature ['-', '-FLOAT', 'LANG:FI', 'TAIL:CAT:INF,A/HEAD'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei T{V}]]

8.

		Adding inflectional features {'TAIL:CAT:INF,A/HEAD', 'LANG:FI', '-FLOAT', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-FLOAT', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:CAT:INF,A/HEAD']

		Consume "D"

		[[D Pekka] [ei T{V}]] + D
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				käske (käske) is missing a mandatory complement A/inf
				Avoid [<D Pekka> [ei [<D Pekka> [T [<D Pekka> käske]]]]] as left branch because it constitutes illicit structure.
				Avoid Neg/finP as SPEC for D due to unselective SPEC feature.
				An EPP-head "ei" lacks specifier but needs one.
				käske (käske) is missing complement A/inf
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T käske]] as left branch because it constitutes illicit structure.
				Avoid TP as SPEC for D due to unselective SPEC feature.
				Avoid [T{V} D] due to local agreement failure.
				Prioritize [T{V} D] due to complement selection.
				[[D Pekka] [ei T{V}]] + D = -197]
				[ei T{V}] + D = -194]
				T{V} + D = -38]
		Ranking completed:
			1. [T{V}; D]
			2. [[ei T{V}]; D]
			3. [[[D Pekka] [ei T{V}]]; D]
		Exploring solution number (1) =[T{V} D]
			T{V} cannot be opened.
			=[[D Pekka] [ei [T{V} D]]]

9.

		Consume "heidän"

		[[D Pekka] [ei [T{V} D]]] + heidän
			Filtering out impossible merge sites...
			Sink "heidän" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*heidän]
			=[[D Pekka] [ei [T{V} D{N}]]]

10.
		Next word contains multiple morphemes ['$-ta', '$v', 'anta-']

		Consume "Ainf"

		[[D Pekka] [ei [T{V} D{N}]]] + Ainf
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske <D heidän>]]]]]] Ainf] due to bad left branch.
				Reject [[ei [T [käske <D heidän>]]] Ainf] due to bad left branch.
				Reject [[T [käske [D heidän]]] Ainf] due to bad left branch.
		Exploring solution number (1) =[D{N} Ainf]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]]

11.

		Consume "v"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf]]]] + v
			Filtering out impossible merge sites...
			Sink "v" into Ainf because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf*v]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]]

12.

		Consume "antaa"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v}]]]] + antaa
			Filtering out impossible merge sites...
			Sink "antaa" into Ainf{v} because they are inside the same phonological word.
		Exploring solution number (1) =[Ainf{v}*antaa]
			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

13.
		Next word contains multiple morphemes ['$par', '$D', 'kirja-']
		Storing inflectional feature ['-', 'LANG:FI', 'TAIL:!COMP:*,-PHI'] into working memory.

		Consume "$D"

			=[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]]

14.

		Adding inflectional features {'LANG:FI', 'TAIL:!COMP:*,-PHI', '-'} to D
		= ['!COMP:*', '!PROBE:CAT:N', '+PHI', '-', '-COMP:T/fin', '-COMP:uR', '-SPEC:*', 'CAT:D', 'COMP:N', 'LANG:FI', 'LF:D', 'PF:D', 'TAIL:!COMP:*,-PHI']

		Consume "D"

		[[D Pekka] [ei [T{V} [[D heidän] Ainf{v,V}]]]] + D
			Filtering out impossible merge sites...
				Reject [[<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]]]]]] D] due to bad left branch.
				Reject [[ei [T [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]]] D] due to bad left branch.
				Reject [[T [käske [[D heidän] [Ainf [[D heidän] [v antaa]]]]]] D] due to bad left branch.
				Reject [[[D heidän] [Ainf [[D heidän] [v antaa]]]] D] due to bad left branch.
		Exploring solution number (1) =[Ainf{v,V} D]
			Ainf{v,V} cannot be opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]]

15.

		Consume "kirja"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D]]]]] + kirja
			Filtering out impossible merge sites...
			Sink "kirja" into D because they are inside the same phonological word.
		Exploring solution number (1) =[D*kirja]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]

16.
		Next word contains multiple morphemes ['$lle', '$D', 'Merja-']

		Consume "P(lle)"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] + P(lle)
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, P(lle).
				Avoid Neg/finP as SPEC, P(lle).
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T [käske [[D heidän] [Ainf [[D heidän] [v [antaa [D kirja]]]]]]]]] as left branch because it constitutes illicit structure.
				Avoid [[T{V} [[D heidän] [Ainf{v,V} D{N}]]], P(lle)] because the operation breaks up an existing selectional dependency.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [T [käske [[D heidän] [Ainf [[D heidän] [v [antaa [D kirja]]]]]]]] as left branch because it constitutes illicit structure.
				Avoid INFP as SPEC, P(lle).
				Avoid INFP as SPEC, P(lle).
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				Avoid [Ainf [v [antaa [D kirja]]]] as left branch because it constitutes illicit structure.
				Avoid [D{N},P(lle)] solution due to semantic mismatch.
				Avoid D{N} because it could break words.
			D was opened.
				Prioritize D{N} because all solutions were negative.
				[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]] + P(lle) = -98]
				[ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]] + P(lle) = -194]
				[T{V} [[D heidän] [Ainf{v,V} D{N}]]] + P(lle) = -191]
				[[D heidän] [Ainf{v,V} D{N}]] + P(lle) = -92]
				[Ainf{v,V} D{N}] + P(lle) = -185]
				D{N} + P(lle) = 18]
		Ranking completed:
			1. [D{N}; P(lle)]
			2. [[[D heidän] [Ainf{v,V} D{N}]]; P(lle)]
			3. [[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]]; P(lle)]
			4. [[Ainf{v,V} D{N}]; P(lle)]
			5. [[T{V} [[D heidän] [Ainf{v,V} D{N}]]]; P(lle)]
			6. [[ei [T{V} [[D heidän] [Ainf{v,V} D{N}]]]]; P(lle)]
		Exploring solution number (1) =[D{N} P(lle)]
			D was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]]]

17.

		Consume "D"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle)]]]]]] + D
			Filtering out impossible merge sites...
			Sink "D" into P(lle) because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle)*D]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]]]

18.

		Consume "Merja-"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D}]]]]]] + Merja-
			Filtering out impossible merge sites...
			Sink "Merja-" into P(lle){D} because they are inside the same phonological word.
		Exploring solution number (1) =[P(lle){D}*Merja-]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]]

19.
		Next word contains multiple morphemes ['$malla', 'heitta_pro-']

		Consume "malla"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]] + malla
			Filtering out impossible merge sites...
			Ranking remaining sites...
				Avoid Neg/finP as SPEC, malla.
				Avoid Neg/finP as SPEC, malla.
				An EPP-head "ei" lacks specifier but needs one.
				An EPP-head "käske" lacks specifier D that it requires.
				Avoid [ei [T [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] <P(lle) [D Merja-]>]]]]]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "käske" lacks specifier D that it requires.
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Avoid [T [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]]]] as left branch because it constitutes illicit structure.
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Avoid [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]]]] as left branch because it constitutes illicit structure.
				An EPP-head "Ainf" lacks specifier D that it requires.
				An EPP-head "v" lacks specifier D that it requires.
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Avoid [Ainf [v [antaa [[D kirja] [P(lle) [D Merja-]]]]]] as left branch because it constitutes illicit structure.
				[D kirja]" has no thematic role
				Avoid [[D kirja] [P(lle) [D Merja-]]] as left branch because it constitutes illicit structure.
				Avoid [P(lle){D,N} malla] due to complement selection.
			P(lle) was opened.
				Prioritize P(lle){D,N} because all solutions were negative.
				[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]] + malla = -98]
				[ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]] + malla = -194]
				[T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]] + malla = -94]
				[[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]] + malla = -92]
				[Ainf{v,V} [[D kirja] P(lle){D,N}]] + malla = -90]
				[[D kirja] P(lle){D,N}] + malla = -88]
				P(lle){D,N} + malla = 114]
		Ranking completed:
			1. [P(lle){D,N}; malla]
			2. [[[D kirja] P(lle){D,N}]; malla]
			3. [[Ainf{v,V} [[D kirja] P(lle){D,N}]]; malla]
			4. [[[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]; malla]
			5. [[T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]; malla]
			6. [[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]]; malla]
			7. [[ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] P(lle){D,N}]]]]]; malla]
		Exploring solution number (1) =[P(lle){D,N} malla]
			P(lle) was opened.
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]]]]

20.

		Consume "heitta"

		[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla]]]]]]] + heitta
			Filtering out impossible merge sites...
			Sink "heitta" into malla because they are inside the same phonological word.
		Exploring solution number (1) =[malla*heitta]
			=[[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]

21.
	>>>	Trying candidate parse [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]] (1.)
		Reconstructing...
			Reconstructing head movement for [[D Pekka] [ei [T{V} [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]].
				Extracted head "käske" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf{v,V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]]
				Extracted head "v{V}" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v{V} [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]]]
				Extracted head "antaa" and reconstructed it = [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] malla{V}]]]]]]]]]]
				Extracted head "heitta" from malla and created [[D Pekka] [ei [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]]]]
			Dropping floaters...
				[D Pekka] failed to tail [A/HEAD][CAT:FIN]
				<D Pekka> was made an adjunct.
				Floater <D Pekka> dropped: [<D Pekka>:37 [ei [<DP>:37 [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] [malla heitta]]]]]]]]]]]]
				<malla heitta> was made an adjunct.
				= [<D Pekka> [ei [<D Pekka> [T [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]]]]
			Dropping A-/A-bar movement.
				Moving "____" into memory buffer from SPEC of "T".
				Memory buffer: [[D N]]
				Dropping constituent <DP>:37 from memory buffer into Spec of käske
				Result [<D Pekka>:37 [ei [<DP>:37 [T [<DP>:37 [käske [[D heidän] [Ainf [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]]]]]
				[D heidän] will undergo A-reconstruction (form of Agree).
				Moving "D kirja " into memory buffer from SPEC of "P(lle)".
				Memory buffer: [[D N]]
				antaa (antaa) is missing a mandatory complement D
				[D kirja]" has no thematic role
				Extraposition will be tried on [<D Pekka>:37 [ei [<DP>:37 [T [<DP>:37 [käske [[D heidän]:39 [Ainf [(DP):39 [v [antaa [[D kirja] [[P(lle) [D Merja-]] <malla heitta>]]]]]]]]]]]]].
				<P(lle) [D Merja-]> was made an adjunct.
				<P(lle) [D Merja-]> was made adjunct by an extraposition rule.
			= [<D Pekka> [ei [<D Pekka> [T [<D Pekka> [käske [[D heidän] [Ainf [[D heidän] [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]]]]]]]
		Checking LF-interface conditions.
			Trying to transfer [<D Pekka>:37 [ei [<DP>:37 [T [<DP>:37 [käske [[D heidän]:39 [Ainf [(DP):39 [v [antaa [[D kirja] <<P(lle) [D Merja-]> <malla heitta>>]]]]]]]]]]]] into LF...
				Transfer to LF successful.
